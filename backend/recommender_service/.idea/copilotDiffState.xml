<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/PROJECT_PREVIEW.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PROJECT_PREVIEW.md" />
              <option name="updatedContent" value="# Product Recommender Service – Preview&#10;&#10;## Tổng quan&#10;Dịch vụ backend viết bằng **FastAPI** cung cấp API gợi ý sản phẩm cho hệ thống quản lý cửa hàng. &#10;Nó kết nối tới **MySQL**, đọc dữ liệu sản phẩm và lịch sử xem sản phẩm của người dùng, sau đó sinh gợi ý bằng mô hình **hybrid (collaborative + content-based)**.&#10;&#10;---&#10;&#10;## Cấu trúc thư mục chính&#10;&#10;```text&#10;recommender_service/&#10;├─ app.py                  # Khởi tạo FastAPI app, CORS, router, health check&#10;├─ config.py               # Cấu hình kết nối DB (host, port, user, password, dbname, ...)&#10;├─ requirements.txt        # Thư viện Python cần thiết&#10;├─ start.bat / start.sh    # Script khởi động service (Windows / Linux)&#10;├─ test_connection.py      # Script test kết nối tới DB&#10;├─ models/                 # (Dự phòng cho class/model, hiện chưa xem chi tiết)&#10;├─ modules/&#10;│   ├─ __init__.py&#10;│   ├─ collaborative.py    # Gợi ý dựa trên lịch sử xem (behavior-based)&#10;│   ├─ content_based.py    # Mô hình content-based (TF-IDF + cosine similarity)&#10;│   ├─ hybrid.py           # Kết hợp collaborative + content-based&#10;│   ├─ loader.py           # Hàm kết nối &amp; truy vấn MySQL (products, view history)&#10;│   └─ preprocess.py       # Xử lý, trích xuất sở thích user từ lịch sử view&#10;└─ routers/&#10;    ├─ __init__.py&#10;    └─ recommend_router.py # Định nghĩa các API /recommend, /similar-products&#10;```&#10;&#10;---&#10;&#10;## Thành phần &amp; chức năng chính&#10;&#10;### 1. `app.py`&#10;- Tạo FastAPI app: `FastAPI(title=&quot;Product Recommender Service&quot;)`.&#10;- Bật **CORS** cho mọi origin (phục vụ frontend dễ dàng call API trong giai đoạn dev).&#10;- Gắn router `recommend_router` với tag `&quot;recommendations&quot;`.&#10;- Các endpoint hệ thống:&#10;  - `GET /`  &#10;    - Trả về `{ &quot;message&quot;: &quot;Product Recommender Service&quot;, &quot;status&quot;: &quot;running&quot; }`.&#10;  - `GET /health`  &#10;    - Gọi `modules.loader.get_connection()` để kiểm tra kết nối DB.  &#10;    - Nếu OK: `{ &quot;status&quot;: &quot;healthy&quot;, &quot;database&quot;: &quot;connected&quot; }`.  &#10;    - Nếu lỗi: `{ &quot;status&quot;: &quot;unhealthy&quot;, &quot;database&quot;: &quot;disconnected&quot;, &quot;error&quot;: ... }`.&#10;- Có hỗ trợ chạy trực tiếp bằng `uvicorn` (port 5000).&#10;&#10;### 2. `routers/recommend_router.py`&#10;Định nghĩa các API chính cho recommender:&#10;&#10;1. **`GET /recommend`**&#10;   - Query param: `userId: int`.&#10;   - Flow:&#10;     - Gọi `hybrid.init_models()` (đã được gọi sẵn khi import module) để đảm bảo model đã được load.&#10;     - Gọi `hybrid.hybrid_recommend(userId, top_k=10)`.&#10;     - Log ra console số lượng sản phẩm gợi ý.&#10;   - Response dạng:&#10;     ```json&#10;     {&#10;       &quot;userId&quot;: 123,&#10;       &quot;recommendations&quot;: [1, 5, 7, ...]&#10;     }&#10;     ```&#10;   - Nếu lỗi: trả về HTTP 500 với chi tiết exception.&#10;&#10;2. **`GET /similar-products`**&#10;   - Query param: `productId: int`.&#10;   - Flow:&#10;     - Gọi `hybrid.similar_products(productId, top_k=10)`.&#10;   - Response dạng:&#10;     ```json&#10;     {&#10;       &quot;productId&quot;: 10,&#10;       &quot;similar&quot;: [3, 8, 11, ...]&#10;     }&#10;     ```&#10;   - Nếu lỗi: trả về HTTP 500.&#10;&#10;### 3. `modules/loader.py`&#10;Các hàm làm việc với **MySQL**:&#10;&#10;- `get_connection()`&#10;  - Tạo kết nối MySQL dùng cấu hình trong `config.py`.&#10;&#10;- `load_products()`&#10;  - Truy vấn bảng `products` (join với `categories`) để lấy:&#10;    - `id_product` → `id`&#10;    - `product_name` → `name`&#10;    - `category_name` → `category`&#10;    - `brand`, `price`, `description`&#10;  - Trả về `pandas.DataFrame` chứa toàn bộ danh sách sản phẩm.&#10;&#10;- `load_user_history(user_id: int, limit: int = 200)`&#10;  - Truy vấn bảng `product_view` để lấy lịch sử xem của 1 user:&#10;    - `id, user_id, session_id, product_id, action_type, created_at`&#10;  - Log chi tiết kết nối, query, số record trả về.&#10;  - Trả về `DataFrame` lịch sử xem, dùng cho collaborative.&#10;&#10;- `load_global_views(limit: int = 5000)`&#10;  - Lấy lịch sử view global (user_id không null) để có thể dùng cho các phân tích/gợi ý nâng cao.&#10;&#10;### 4. `modules/preprocess.py`&#10;Xử lý dữ liệu lịch sử xem để suy ra **sở thích người dùng**:&#10;&#10;- `get_user_preference_from_views(views_df, products_df)`&#10;  - Merge lịch sử view (`views_df`) với danh sách sản phẩm (`products_df`) theo `product_id` ↔ `id`.&#10;  - Đếm tần suất:&#10;    - `category`&#10;    - `brand`&#10;  - Trả về:&#10;    ```python&#10;    {&#10;      &quot;categories&quot;: [top 5 categories],&#10;      &quot;brands&quot;: [top 5 brands]&#10;    }&#10;    ```&#10;  - Nếu dữ liệu trống → trả về list rỗng.&#10;&#10;### 5. `modules/collaborative.py`&#10;Gợi ý dựa trên **hành vi** (view history) – dạng collaborative/behavior-based đơn giản:&#10;&#10;- `recommend_by_view_history(user_id: int, products_df: pd.DataFrame, top_k: int = 10)`&#10;  - Gọi `loader.load_user_history(user_id, limit=200)` để lấy lịch sử xem.&#10;  - Nếu user chưa có lịch sử → trả về `[]`.&#10;  - Gọi `preprocess.get_user_preference_from_views(...)` để lấy danh sách category/brand ưa thích.&#10;  - Tạo danh sách **candidate** từ tất cả sản phẩm:&#10;    - Khởi tạo cột `score = 0`.&#10;    - Nếu `category` nằm trong `preferences[&quot;categories&quot;]` → `score += 2`.&#10;    - Nếu `brand` nằm trong `preferences[&quot;brands&quot;]` → `score += 1`.&#10;  - Loại bỏ các sản phẩm mà user đã xem (`views_df[&quot;product_id&quot;]`).&#10;  - Sắp xếp giảm dần theo `score`, lấy `top_k * 2` sản phẩm (để hybrid có thêm dữ liệu).&#10;  - Trả về list ID sản phẩm.&#10;&#10;### 6. `modules/content_based.py`&#10;Mô hình **content-based** dùng TF-IDF + cosine similarity:&#10;&#10;- Biến global:&#10;  - `_products_df`: bản copy DataFrame sản phẩm.&#10;  - `_vectorizer`: `TfidfVectorizer`.&#10;  - `_similarity_matrix`: ma trận cosine similarity giữa các sản phẩm.&#10;&#10;- `init_content_model(products_df)`&#10;  - Gộp các trường text:&#10;    - `category`, `brand`, `description` → cột `text`.&#10;  - Khởi tạo `TfidfVectorizer(max_features=5000, stop_words='english')`.&#10;  - Fit-transform trên cột `text` để tạo ma trận TF-IDF.&#10;  - Tính `cosine_similarity` giữa các vector → `_similarity_matrix`.&#10;&#10;- `similar_products(product_id: int, top_k: int = 10)`&#10;  - Kiểm tra model đã được init chưa, nếu chưa → raise error.&#10;  - Tìm index của sản phẩm trong `_products_df` theo `id`.&#10;  - Lấy hàng tương ứng trong `_similarity_matrix` để được vector similarity.&#10;  - Sắp xếp giảm dần, bỏ chính nó, lấy `top_k` sản phẩm tương tự.&#10;  - Trả về list ID sản phẩm tương tự.&#10;&#10;### 7. `modules/hybrid.py`&#10;Kết hợp **collaborative + content-based**:&#10;&#10;- Biến global:&#10;  - `_initialized`: flag cho biết model đã init hay chưa.&#10;  - `_products_df`: cache danh sách sản phẩm.&#10;&#10;- `init_models()`&#10;  - Nếu đã init → return.&#10;  - Gọi `loader.load_products()` để lấy tất cả sản phẩm.&#10;  - Gọi `content_based.init_content_model(_products_df)` để build model content-based.&#10;  - Đánh dấu `_initialized = True`.&#10;&#10;- `hybrid_recommend(user_id: int, top_k: int = 10)`&#10;  - Đảm bảo model đã init.&#10;  - Gọi `collaborative.recommend_by_view_history(user_id, _products_df, top_k * 2)`.&#10;  - Nếu không có gợi ý collaborative → trả về `[]`.&#10;  - Với 1–2 sản phẩm đầu tiên từ collaborative, gọi `content_based.similar_products(product_id, top_k=5)` để lấy danh sách similar, gom vào `similar_products_list`.&#10;  - Trộn 2 danh sách (collaborative trước, rồi similar), loại bỏ trùng lặp, giữ nguyên thứ tự.&#10;  - Cắt còn `top_k` ID sản phẩm và trả về.&#10;&#10;- `similar_products(product_id: int, top_k: int = 10)`&#10;  - Đảm bảo model đã init.&#10;  - Gọi trực tiếp `content_based.similar_products(product_id, top_k)`.&#10;&#10;---&#10;&#10;## Cách hoạt động tổng quan&#10;&#10;1. Service khởi động → `hybrid.init_models()` được gọi (khi import `recommend_router`):&#10;   - Load tất cả sản phẩm từ MySQL.&#10;   - Build TF-IDF và similarity matrix cho content-based.&#10;&#10;2. Khi gọi `GET /recommend?userId=...`:&#10;   - Lấy lịch sử xem của user từ `product_view`.&#10;   - Phân tích để tìm ra category/brand ưa thích.&#10;   - Chấm điểm sản phẩm mới dựa trên sở thích (collaborative/behavior-based).&#10;   - Lấy một vài sản phẩm được đề xuất, mở rộng thêm các sản phẩm tương tự nội dung (content-based).&#10;   - Trả về danh sách ID sản phẩm gợi ý.&#10;&#10;3. Khi gọi `GET /similar-products?productId=...`:&#10;   - Dùng ma trận similarity để tìm các sản phẩm có nội dung gần nhất (cùng category/brand/mô tả tương tự).&#10;&#10;---&#10;&#10;## Gợi ý sử dụng (development)&#10;&#10;- Cài dependencies (trên Windows, dùng `cmd`):&#10;  ```cmd&#10;  cd D:\project1\store_management\backend\recommender_service&#10;  pip install -r requirements.txt&#10;  ```&#10;&#10;- Chạy service bằng Uvicorn:&#10;  ```cmd&#10;  cd D:\project1\store_management\backend\recommender_service&#10;  python -m uvicorn app:app --reload --port 5000&#10;  ```&#10;&#10;- Kiểm tra nhanh:&#10;  - `GET http://localhost:5000/`  &#10;  - `GET http://localhost:5000/health`  &#10;  - `GET http://localhost:5000/recommend?userId=1`  &#10;  - `GET http://localhost:5000/similar-products?productId=1`&#10;&#10;---&#10;&#10;## Tóm tắt&#10;- Backend nhỏ gọn, tách rõ phần **API**, **loader (DB)**, **tiền xử lý**, và **logic gợi ý**.&#10;- Hỗ trợ 2 chức năng chính: gợi ý sản phẩm theo user và tìm sản phẩm tương tự.&#10;- Mô hình gợi ý dùng chiến lược **hybrid**: kết hợp hành vi người dùng và nội dung sản phẩm để cải thiện chất lượng gợi ý.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>