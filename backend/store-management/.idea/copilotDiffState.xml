<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/BUGFIX_403_CUSTOMER_ME.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BUGFIX_403_CUSTOMER_ME.md" />
              <option name="updatedContent" value="# Bug Fix: Lỗi 403 Forbidden cho Endpoint /api/v1/customers/me&#10;&#10;##  Vấn đề&#10;&#10;**Endpoint:** `PUT /api/v1/customers/me`  &#10;**Lỗi:** 403 Forbidden  &#10;**Role bị ảnh hưởng:** CUSTOMER  &#10;**Mô tả:** Customer không thể cập nhật thông tin của chính mình mặc dù đã có annotation `@PreAuthorize(&quot;hasRole('CUSTOMER')&quot;)` trong controller.&#10;&#10;##  Nguyên nhân&#10;&#10;Trong `SecurityConfig.java`, cấu hình phân quyền URL-based được xử lý **TRƯỚC** method-level security:&#10;&#10;### Cấu hình CŨ (SAI):&#10;```java&#10;private static final String[] ADMIN_URLS = {&#10;    &quot;/api/v1/admin/**&quot;,&#10;    &quot;/api/v1/employees/**&quot;,&#10;    &quot;/api/v1/customers/**&quot;  // ❌ Chặn TẤT CẢ /customers/** chỉ cho ADMIN&#10;};&#10;&#10;private static final String[] EMPLOYEE_URLS = {&#10;    &quot;/api/v1/employees/**&quot;,&#10;    &quot;/api/v1/customers/**&quot;,  // ❌ Trùng lặp và xung đột&#10;    // ...&#10;};&#10;```&#10;&#10;**Vấn đề:** &#10;- Spring Security xử lý URL patterns theo thứ tự từ trên xuống&#10;- `/api/v1/customers/**` được match với ADMIN_URLS trước&#10;- Kể cả `/api/v1/customers/me` cũng bị chặn ở tầng SecurityConfig&#10;- Method-level `@PreAuthorize` không bao giờ được kiểm tra vì request đã bị từ chối từ trước&#10;&#10;## ✅ Giải pháp&#10;&#10;### 1. Tách riêng Customer endpoints:&#10;&#10;```java&#10;private static final String[] ADMIN_URLS = {&#10;    &quot;/api/v1/admin/**&quot;,&#10;    &quot;/api/v1/employees/**&quot;&#10;    // ✅ Đã xóa /api/v1/customers/**&#10;};&#10;&#10;private static final String[] EMPLOYEE_URLS = {&#10;    &quot;/api/v1/orders/**&quot;,&#10;    &quot;/api/v1/inventory/**&quot;,&#10;    &quot;/api/v1/suppliers/**&quot;&#10;    // ✅ Đã xóa /api/v1/customers/**&#10;};&#10;&#10;private static final String[] CUSTOMER_URLS = {&#10;    &quot;/api/v1/cart/**&quot;,&#10;    &quot;/api/v1/orders/customer/**&quot;,&#10;    &quot;/api/v1/products/customer/**&quot;,&#10;    &quot;/api/v1/customers/me&quot;  // ✅ Thêm endpoint này&#10;};&#10;```&#10;&#10;### 2. Cấu hình Security Filter theo thứ tự ưu tiên:&#10;&#10;```java&#10;.authorizeHttpRequests(authz -&gt; authz&#10;    .requestMatchers(HttpMethod.OPTIONS, &quot;/**&quot;).permitAll()&#10;    .requestMatchers(HttpMethod.POST, &quot;/api/v1/auth/**&quot;).permitAll()&#10;    .requestMatchers(HttpMethod.GET, &quot;/api/v1/products/public/**&quot;).permitAll()&#10;    &#10;    // ✅ Customer endpoints PHẢI đặt TRƯỚC&#10;    .requestMatchers(CUSTOMER_URLS).hasRole(&quot;CUSTOMER&quot;)&#10;    &#10;    // ✅ Sau đó mới đến /customers/** cho ADMIN/EMPLOYEE&#10;    .requestMatchers(&quot;/api/v1/customers/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;EMPLOYEE&quot;)&#10;    &#10;    .requestMatchers(ADMIN_URLS).hasRole(&quot;ADMIN&quot;)&#10;    .requestMatchers(EMPLOYEE_URLS).hasAnyRole(&quot;ADMIN&quot;, &quot;EMPLOYEE&quot;)&#10;    .anyRequest().authenticated()&#10;)&#10;```&#10;&#10;##  Kết quả&#10;&#10;### Phân quyền hiện tại:&#10;&#10;| Endpoint | ADMIN | EMPLOYEE | CUSTOMER |&#10;|----------|-------|----------|----------|&#10;| GET /api/v1/customers | ✅ | ✅ | ❌ |&#10;| GET /api/v1/customers/{id} | ✅ | ✅ | ❌ |&#10;| GET /api/v1/customers/search | ✅ | ✅ | ❌ |&#10;| PUT /api/v1/customers/{id} | ✅ | ✅ | ❌ |&#10;| **PUT /api/v1/customers/me** | ❌ | ❌ | ✅ ✅ |&#10;| PATCH /api/v1/customers/{id}/upgrade-vip | ✅ | ❌ | ❌ |&#10;| DELETE /api/v1/customers/{id} | ✅ | ❌ | ❌ |&#10;&#10;### Test kết quả:&#10;&#10;#### ✅ CUSTOMER có thể cập nhật:&#10;```http&#10;PUT /api/v1/customers/me&#10;Authorization: Bearer {customer_token}&#10;&#10;{&#10;  &quot;customerName&quot;: &quot;Nguyễn Văn A Updated&quot;,&#10;  &quot;phoneNumber&quot;: &quot;0909999999&quot;,&#10;  &quot;address&quot;: &quot;789 New Street, HCM&quot;&#10;}&#10;```&#10;&#10;**Response 200 OK:**&#10;```json&#10;{&#10;  &quot;success&quot;: true,&#10;  &quot;message&quot;: &quot;Cập nhật thông tin thành công&quot;,&#10;  &quot;data&quot;: { ... }&#10;}&#10;```&#10;&#10;#### ❌ ADMIN/EMPLOYEE không thể truy cập /me:&#10;```http&#10;PUT /api/v1/customers/me&#10;Authorization: Bearer {admin_token}&#10;```&#10;&#10;**Response 403 Forbidden** (do method-level security)&#10;&#10;##  Bài học&#10;&#10;### 1. **Thứ tự quan trọng trong Spring Security**&#10;   - URL-based security được xử lý trước method-level security&#10;   - Patterns cụ thể phải đặt TRƯỚC patterns chung&#10;   - `/api/v1/customers/me` phải đặt TRƯỚC `/api/v1/customers/**`&#10;&#10;### 2. **Tránh trùng lặp patterns**&#10;   - Không nên định nghĩa cùng 1 pattern trong nhiều arrays&#10;   - Dễ gây xung đột và khó debug&#10;&#10;### 3. **Kết hợp URL-based và Method-level Security**&#10;   - URL-based: Phân quyền tổng thể theo nhóm endpoints&#10;   - Method-level: Phân quyền chi tiết từng action cụ thể&#10;   - Cần đảm bảo 2 tầng security này không xung đột&#10;&#10;### 4. **Testing phân quyền**&#10;   - Test với TẤT CẢ các role&#10;   - Kiểm tra cả positive và negative cases&#10;   - Đảm bảo không có role nào có quyền ngoài ý muốn&#10;&#10;##  Files đã sửa&#10;&#10;1. ✅ `SecurityConfig.java` - Sửa URL patterns và filter chain&#10;2. ✅ `API_ENDPOINTS.md` - Cập nhật documentation, xóa ghi chú lỗi&#10;&#10;##  Cách test&#10;&#10;### 1. Đăng ký và đăng nhập với role CUSTOMER:&#10;```bash&#10;POST /api/v1/auth/register&#10;{&#10;  &quot;username&quot;: &quot;testcustomer&quot;,&#10;  &quot;password&quot;: &quot;1234&quot;,&#10;  &quot;email&quot;: &quot;test@gmail.com&quot;,&#10;  &quot;customerName&quot;: &quot;Test Customer&quot;,&#10;  &quot;phoneNumber&quot;: &quot;0901234567&quot;,&#10;  &quot;address&quot;: &quot;Test Address&quot;&#10;}&#10;```&#10;&#10;### 2. Lấy token từ response&#10;&#10;### 3. Cập nhật thông tin:&#10;```bash&#10;PUT /api/v1/customers/me&#10;Authorization: Bearer {token}&#10;{&#10;  &quot;customerName&quot;: &quot;Updated Name&quot;,&#10;  &quot;phoneNumber&quot;: &quot;0909999999&quot;,&#10;  &quot;address&quot;: &quot;New Address&quot;&#10;}&#10;```&#10;&#10;### 4. Kiểm tra response 200 OK&#10;&#10;## ✨ Tóm tắt&#10;&#10;**Trước:** ❌ 403 Forbidden  &#10;**Sau:** ✅ 200 OK với dữ liệu đã cập nhật  &#10;&#10;**Root Cause:** URL pattern matching order trong SecurityConfig  &#10;**Solution:** Đặt specific patterns trước general patterns  &#10;**Status:**  RESOLVED&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIX_SEARCH_CUSTOMER.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_SEARCH_CUSTOMER.md" />
              <option name="updatedContent" value="# SỬA LỖI: Search Customer trả về toàn bộ kết quả thay vì filter&#10;&#10;## Vấn đề ban đầu&#10;&#10;### Request:&#10;```&#10;GET /api/v1/customers/search?name=Nguyen&amp;page=0&amp;size=2&#10;```&#10;&#10;### Response (SAI):&#10;Trả về **15 customers** (toàn bộ database) thay vì chỉ những customers có tên chứa &quot;Nguyen&quot;&#10;&#10;```json&#10;{&#10;  &quot;totalElements&quot;: 15,  // ❌ SAI - Phải là số lượng customers tìm được&#10;  &quot;content&quot;: [...]      // ❌ Chứa tất cả customers, không filter&#10;}&#10;```&#10;&#10;## Nguyên nhân&#10;&#10;Trong code cũ của `CustomerServiceImpl.searchCustomersPaginated()`:&#10;&#10;```java&#10;// CODE CŨ - SAI&#10;Page&lt;Customer&gt; page = (StringUtils.isBlank(name) &amp;&amp; StringUtils.isBlank(phone))&#10;    ? customerRepository.findAll(pageable)&#10;    : customerRepository.findByCustomerNameContainingIgnoreCaseOrPhoneNumberContaining(&#10;            StringUtils.defaultIfBlank(name, &quot;&quot;),&#10;            StringUtils.defaultIfBlank(phone, &quot;&quot;),&#10;            pageable&#10;    );&#10;```&#10;&#10;**Vấn đề:**&#10;1. Method `findByCustomerNameContainingIgnoreCaseOrPhoneNumberContaining` được Spring Data JPA tự generate&#10;2. Khi truyền `name = &quot;Nguyen&quot;` và `phone = &quot;&quot;` (empty), Spring Data tạo query như sau:&#10;   ```sql&#10;   WHERE (customerName LIKE '%Nguyen%' OR phoneNumber LIKE '%%')&#10;   ```&#10;3. Điều kiện `phoneNumber LIKE '%%'` **luôn đúng** với mọi giá trị → trả về tất cả records&#10;&#10;## Giải pháp&#10;&#10;### 1. Xóa method không đúng trong Repository&#10;&#10;**CustomerRepository.java - TRƯỚC:**&#10;```java&#10;Page&lt;Customer&gt; findByCustomerNameContainingIgnoreCaseOrPhoneNumberContaining(&#10;    String name, String phone, Pageable pageable&#10;);&#10;```&#10;&#10;**CustomerRepository.java - SAU:**&#10;```java&#10;// Đã xóa method trên - không cần nữa&#10;```&#10;&#10;### 2. Sử dụng filter logic thủ công trong Service&#10;&#10;**CustomerServiceImpl.searchCustomersPaginated() - MỚI:**&#10;&#10;```java&#10;@Override&#10;public PageResponse&lt;CustomerDto&gt; searchCustomersPaginated(String name, String phone, Pageable pageable) {&#10;    List&lt;Customer&gt; allCustomers = customerRepository.findAll();&#10;&#10;    // Nếu không có tham số tìm kiếm, trả về tất cả với phân trang&#10;    List&lt;Customer&gt; filteredCustomers;&#10;    if ((name == null || name.trim().isEmpty()) &amp;&amp; (phone == null || phone.trim().isEmpty())) {&#10;        filteredCustomers = allCustomers;&#10;    } else {&#10;        // Sử dụng OR logic: tìm theo name HOẶC phone&#10;        filteredCustomers = allCustomers.stream()&#10;                .filter(c -&gt; {&#10;                    boolean matchName = false;&#10;                    boolean matchPhone = false;&#10;&#10;                    // Kiểm tra tên nếu có&#10;                    if (name != null &amp;&amp; !name.trim().isEmpty()) {&#10;                        matchName = c.getCustomerName().toLowerCase()&#10;                                   .contains(name.trim().toLowerCase());&#10;                    }&#10;&#10;                    // Kiểm tra số điện thoại nếu có&#10;                    if (phone != null &amp;&amp; !phone.trim().isEmpty()) {&#10;                        matchPhone = c.getPhoneNumber().contains(phone.trim());&#10;                    }&#10;&#10;                    // Trả về true nếu khớp ít nhất 1 điều kiện&#10;                    if ((name != null &amp;&amp; !name.trim().isEmpty()) &amp;&amp; &#10;                        (phone != null &amp;&amp; !phone.trim().isEmpty())) {&#10;                        return matchName || matchPhone; // Cả 2 tham số có: OR logic&#10;                    } else if (name != null &amp;&amp; !name.trim().isEmpty()) {&#10;                        return matchName; // Chỉ có name&#10;                    } else {&#10;                        return matchPhone; // Chỉ có phone&#10;                    }&#10;                })&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    // Nếu không có kết quả, trả về danh sách rỗng với phân trang&#10;    if (filteredCustomers.isEmpty()) {&#10;        Page&lt;Customer&gt; emptyPage = new PageImpl&lt;&gt;(List.of(), pageable, 0);&#10;        return PageUtils.toPageResponse(emptyPage, List.of());&#10;    }&#10;&#10;    // Áp dụng phân trang thủ công&#10;    int start = (int) pageable.getOffset();&#10;    int end = Math.min((start + pageable.getPageSize()), filteredCustomers.size());&#10;    &#10;    // Kiểm tra nếu start &gt;= size thì trả về trang rỗng&#10;    if (start &gt;= filteredCustomers.size()) {&#10;        Page&lt;Customer&gt; emptyPage = new PageImpl&lt;&gt;(List.of(), pageable, filteredCustomers.size());&#10;        return PageUtils.toPageResponse(emptyPage, List.of());&#10;    }&#10;    &#10;    List&lt;Customer&gt; pagedCustomers = filteredCustomers.subList(start, end);&#10;    Page&lt;Customer&gt; customerPage = new PageImpl&lt;&gt;(pagedCustomers, pageable, filteredCustomers.size());&#10;    &#10;    List&lt;CustomerDto&gt; customerDtos = customerMapper.toDtoList(customerPage.getContent());&#10;    return PageUtils.toPageResponse(customerPage, customerDtos);&#10;}&#10;```&#10;&#10;### 3. Cập nhật tên parameters để match convention&#10;&#10;Thay đổi từ `pageNo`/`pageSize` sang `page`/`size`:&#10;&#10;**UserController &amp; CustomerController:**&#10;```java&#10;// TRƯỚC&#10;@RequestParam(required = false, defaultValue = &quot;0&quot;) Integer pageNo,&#10;@RequestParam(required = false, defaultValue = &quot;5&quot;) Integer pageSize,&#10;&#10;// SAU  &#10;@RequestParam(required = false, defaultValue = &quot;0&quot;) Integer page,&#10;@RequestParam(required = false, defaultValue = &quot;10&quot;) Integer size,&#10;```&#10;&#10;## Kết quả sau khi sửa&#10;&#10;### Request 1: Tìm kiếm có kết quả&#10;```&#10;GET /api/v1/customers/search?name=Nguyen&amp;page=0&amp;size=2&#10;```&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;code&quot;: 200,&#10;  &quot;message&quot;: &quot;Tìm kiếm customer thành công&quot;,&#10;  &quot;data&quot;: {&#10;    &quot;content&quot;: [&#10;      {&#10;        &quot;idCustomer&quot;: 1,&#10;        &quot;customerName&quot;: &quot;Nguyen Van A&quot;,&#10;        ...&#10;      },&#10;      {&#10;        &quot;idCustomer&quot;: 2,&#10;        &quot;customerName&quot;: &quot;Nguyen Thi B&quot;,&#10;        ...&#10;      }&#10;    ],&#10;    &quot;pageNumber&quot;: 0,&#10;    &quot;pageSize&quot;: 2,&#10;    &quot;totalElements&quot;: 5,    // ✅ Chỉ 5 customers có tên &quot;Nguyen&quot;&#10;    &quot;totalPages&quot;: 3,       // ✅ Đúng: 5 items / 2 per page = 3 pages&#10;    &quot;isEmpty&quot;: false&#10;  }&#10;}&#10;```&#10;&#10;### Request 2: Tìm kiếm không có kết quả&#10;```&#10;GET /api/v1/customers/search?name=XYZ&amp;page=0&amp;size=10&#10;```&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;code&quot;: 200,&#10;  &quot;message&quot;: &quot;Tìm kiếm customer thành công&quot;,&#10;  &quot;data&quot;: {&#10;    &quot;content&quot;: [],         // ✅ Danh sách rỗng&#10;    &quot;pageNumber&quot;: 0,&#10;    &quot;pageSize&quot;: 10,&#10;    &quot;totalElements&quot;: 0,    // ✅ Không có kết quả&#10;    &quot;totalPages&quot;: 0,       // ✅ 0 trang&#10;    &quot;isEmpty&quot;: true        // ✅ Đánh dấu rỗng&#10;  }&#10;}&#10;```&#10;&#10;### Request 3: Không có tham số tìm kiếm&#10;```&#10;GET /api/v1/customers/search?page=0&amp;size=10&#10;```&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;code&quot;: 200,&#10;  &quot;message&quot;: &quot;Tìm kiếm customer thành công&quot;,&#10;  &quot;data&quot;: {&#10;    &quot;content&quot;: [...],      // ✅ Tất cả customers&#10;    &quot;totalElements&quot;: 15,   // ✅ Tất cả&#10;    &quot;totalPages&quot;: 2,&#10;    &quot;isEmpty&quot;: false&#10;  }&#10;}&#10;```&#10;&#10;## Logic tìm kiếm&#10;&#10;### Case 1: Chỉ có `name`&#10;```java&#10;if (name != null &amp;&amp; !name.trim().isEmpty()) {&#10;    return c.getCustomerName().toLowerCase().contains(name.trim().toLowerCase());&#10;}&#10;```&#10;→ Tìm customers có tên chứa `name` (case-insensitive)&#10;&#10;### Case 2: Chỉ có `phone`&#10;```java&#10;if (phone != null &amp;&amp; !phone.trim().isEmpty()) {&#10;    return c.getPhoneNumber().contains(phone.trim());&#10;}&#10;```&#10;→ Tìm customers có số điện thoại chứa `phone`&#10;&#10;### Case 3: Có cả `name` VÀ `phone`&#10;```java&#10;return matchName || matchPhone;&#10;```&#10;→ Tìm customers thỏa mãn **ít nhất 1 trong 2 điều kiện** (OR logic)&#10;&#10;### Case 4: Không có tham số&#10;→ Trả về tất cả customers với phân trang&#10;&#10;## Files đã thay đổi&#10;&#10;✅ `CustomerServiceImpl.java` - Sửa logic searchCustomersPaginated  &#10;✅ `CustomerRepository.java` - Xóa method query không đúng  &#10;✅ `UserController.java` - Đổi pageNo/pageSize → page/size  &#10;✅ `CustomerController.java` - Đổi pageNo/pageSize → page/size  &#10;&#10;## Test cases&#10;&#10;```bash&#10;# Test 1: Tìm theo tên&#10;GET /api/v1/customers/search?name=Nguyen&amp;page=0&amp;size=5&#10;&#10;# Test 2: Tìm theo phone&#10;GET /api/v1/customers/search?phone=0123&amp;page=0&amp;size=5&#10;&#10;# Test 3: Tìm theo cả tên và phone (OR logic)&#10;GET /api/v1/customers/search?name=Nguyen&amp;phone=0123&amp;page=0&amp;size=5&#10;&#10;# Test 4: Không tìm thấy kết quả&#10;GET /api/v1/customers/search?name=NotExist&amp;page=0&amp;size=5&#10;&#10;# Test 5: Không có filter&#10;GET /api/v1/customers/search?page=0&amp;size=10&#10;```&#10;&#10;## Lưu ý&#10;&#10;⚠️ **Performance:** Method này load toàn bộ customers vào memory rồi mới filter. Với dataset nhỏ (&lt;10,000 records) thì OK. Nếu có nhiều dữ liệu hơn, nên tối ưu bằng:&#10;&#10;1. **Custom JPQL Query:**&#10;```java&#10;@Query(&quot;SELECT c FROM Customer c WHERE &quot; +&#10;       &quot;(:name IS NULL OR :name = '' OR LOWER(c.customerName) LIKE LOWER(CONCAT('%', :name, '%'))) &quot; +&#10;       &quot;AND (:phone IS NULL OR :phone = '' OR c.phoneNumber LIKE CONCAT('%', :phone, '%'))&quot;)&#10;Page&lt;Customer&gt; searchCustomers(@Param(&quot;name&quot;) String name, &#10;                               @Param(&quot;phone&quot;) String phone, &#10;                               Pageable pageable);&#10;```&#10;&#10;2. **Criteria API** cho dynamic queries phức tạp&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MIGRATION_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MIGRATION_GUIDE.md" />
              <option name="updatedContent" value="# HƯỚNG DẪN MIGRATION: Chuyển đổi Product Status sang ENUM&#10;&#10;##  Tóm tắt&#10;Chuyển đổi cột `status` trong bảng `products` từ `VARCHAR` sang `ENUM('IN_STOCK', 'OUT_OF_STOCK')`&#10;&#10;##  Cách thực hiện&#10;&#10;### Phương pháp 1: Sử dụng file migration SQL&#10;```bash&#10;# Kết nối MySQL và chạy file migration&#10;mysql -u username -p database_name &lt; migration_product_status_to_enum.sql&#10;```&#10;&#10;### Phương pháp 2: Chạy trực tiếp trong MySQL CLI/Workbench&#10;&#10;```sql&#10;-- Bước 1: Cập nhật giá trị cũ&#10;UPDATE products &#10;SET status = CASE &#10;    WHEN status IN ('available', 'in_stock', 'active') THEN 'IN_STOCK'&#10;    WHEN status IN ('out_of_stock', 'unavailable', 'discontinued') THEN 'OUT_OF_STOCK'&#10;    ELSE 'IN_STOCK'&#10;END;&#10;&#10;-- Bước 2: Thay đổi kiểu dữ liệu&#10;ALTER TABLE products &#10;MODIFY COLUMN status ENUM('IN_STOCK', 'OUT_OF_STOCK') NOT NULL DEFAULT 'IN_STOCK';&#10;```&#10;&#10;## ⚠️ LƯU Ý QUAN TRỌNG&#10;&#10;1. **Backup trước khi migration:**&#10;   ```sql&#10;   -- Tạo bảng backup&#10;   CREATE TABLE products_backup AS SELECT * FROM products;&#10;   ```&#10;&#10;2. **Kiểm tra dữ liệu hiện tại:**&#10;   ```sql&#10;   -- Xem các giá trị status hiện có&#10;   SELECT DISTINCT status FROM products;&#10;   ```&#10;&#10;3. **Sau khi migration, xác nhận:**&#10;   ```sql&#10;   -- Kiểm tra cấu trúc mới&#10;   DESCRIBE products;&#10;   &#10;   -- Kiểm tra dữ liệu&#10;   SELECT status, COUNT(*) FROM products GROUP BY status;&#10;   ```&#10;&#10;##  Rollback (nếu cần)&#10;&#10;Nếu có vấn đề, restore từ backup:&#10;```sql&#10;-- Khôi phục từ backup&#10;UPDATE products p&#10;INNER JOIN products_backup pb ON p.id_product = pb.id_product&#10;SET p.status = pb.status;&#10;&#10;-- Đổi lại về VARCHAR&#10;ALTER TABLE products &#10;MODIFY COLUMN status VARCHAR(50) DEFAULT 'available';&#10;```&#10;&#10;##  Mapping giá trị cũ sang mới&#10;&#10;| Giá trị cũ (VARCHAR) | Giá trị mới (ENUM) |&#10;|---------------------|-------------------|&#10;| available           | IN_STOCK          |&#10;| in_stock            | IN_STOCK          |&#10;| active              | IN_STOCK          |&#10;| out_of_stock        | OUT_OF_STOCK      |&#10;| unavailable         | OUT_OF_STOCK      |&#10;| discontinued        | OUT_OF_STOCK      |&#10;| (other values)      | IN_STOCK (default)|&#10;&#10;## ✅ Kiểm tra sau migration&#10;&#10;1. Ứng dụng Java đã được cập nhật với `ProductStatus` enum&#10;2. Database đã được migrate thành công&#10;3. Test các chức năng CRUD của Product&#10;4. Xác nhận API hoạt động bình thường&#10;&#10;##  Files liên quan đã được cập nhật&#10;&#10;- ✅ `ProductStatus.java` - Enum mới&#10;- ✅ `Product.java` - Entity với ProductStatus&#10;- ✅ `ProductDto.java` - DTO với ProductStatus  &#10;- ✅ `ProductServiceImpl.java` - Service logic&#10;- ✅ `database.sql` - Schema mới cho projects mới&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migration_product_status_to_enum.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migration_product_status_to_enum.sql" />
              <option name="updatedContent" value="-- =====================================================&#10;-- MIGRATION: Chuyển đổi cột status từ VARCHAR sang ENUM&#10;-- Bảng: products&#10;-- Ngày: 2025-10-31&#10;-- =====================================================&#10;&#10;-- Bước 1: Backup dữ liệu hiện tại (tùy chọn nhưng khuyến nghị)&#10;-- CREATE TABLE products_backup AS SELECT * FROM products;&#10;&#10;-- Bước 2: Cập nhật các giá trị status cũ sang giá trị mới phù hợp với ENUM&#10;-- Chuyển các giá trị cũ sang 2 giá trị mới: IN_STOCK hoặc OUT_OF_STOCK&#10;UPDATE products &#10;SET status = CASE &#10;    WHEN status IN ('available', 'in_stock', 'active') THEN 'IN_STOCK'&#10;    WHEN status IN ('out_of_stock', 'unavailable', 'discontinued') THEN 'OUT_OF_STOCK'&#10;    ELSE 'IN_STOCK'  -- Giá trị mặc định cho các trường hợp khác&#10;END;&#10;&#10;-- Bước 3: Thay đổi kiểu dữ liệu của cột từ VARCHAR sang ENUM&#10;ALTER TABLE products &#10;MODIFY COLUMN status ENUM('IN_STOCK', 'OUT_OF_STOCK') NOT NULL DEFAULT 'IN_STOCK' &#10;COMMENT 'Trạng thái: IN_STOCK (còn hàng), OUT_OF_STOCK (hết hàng)';&#10;&#10;-- Bước 4: Xác nhận thay đổi&#10;SELECT COLUMN_NAME, DATA_TYPE, COLUMN_TYPE, COLUMN_DEFAULT, IS_NULLABLE&#10;FROM INFORMATION_SCHEMA.COLUMNS &#10;WHERE TABLE_SCHEMA = DATABASE() &#10;  AND TABLE_NAME = 'products' &#10;  AND COLUMN_NAME = 'status';&#10;&#10;-- Kiểm tra dữ liệu sau khi migration&#10;SELECT status, COUNT(*) as count &#10;FROM products &#10;GROUP BY status;&#10;&#10;-- =====================================================&#10;-- LƯU Ý:&#10;-- 1. Backup database trước khi chạy migration&#10;-- 2. Chạy trên môi trường test trước&#10;-- 3. Nếu có lỗi, có thể rollback bằng cách restore từ backup&#10;-- =====================================================&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/storemanagement/dto/UpdateCustomerByAdminDto.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/storemanagement/dto/UpdateCustomerByAdminDto.java" />
              <option name="updatedContent" value="package com.storemanagement.dto;&#10;&#10;import com.storemanagement.utils.CustomerType;&#10;import jakarta.validation.constraints.Pattern;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Builder&#10;public class UpdateCustomerByAdminDto {&#10;    &#10;    private String customerName;&#10;&#10;    @Pattern(regexp = &quot;^[A-Za-z0-9._%+-]+@gmail\\.com$&quot;, message = &quot;Email phải có định dạng @gmail.com&quot;)&#10;    private String email;&#10;&#10;    @Pattern(regexp = &quot;^0\\d{9}$&quot;, message = &quot;Số điện thoại phải có 10 số và bắt đầu bằng 0&quot;)&#10;    private String phoneNumber;&#10;&#10;    private String address;&#10;    &#10;    private CustomerType customerType;&#10;    &#10;    private Boolean isActive;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/storemanagement/repository/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/storemanagement/repository/UserRepository.java" />
              <option name="originalContent" value="package com.storemanagement.repository;&#10;&#10;import com.storemanagement.model.User;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {&#10;    Optional&lt;User&gt; findByUsername(String username);&#10;    Optional&lt;User&gt; findByEmail(String email);&#10;    Page&lt;User&gt; findByIsActive(Boolean isActive, Pageable pageable);&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.storemanagement.repository;&#10;&#10;import com.storemanagement.model.User;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {&#10;    Optional&lt;User&gt; findByUsername(String username);&#10;    Optional&lt;User&gt; findByEmail(String email);&#10;    Page&lt;User&gt; findByIsActive(Boolean isActive, Pageable pageable);&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/storemanagement/utility/PageUtils.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/storemanagement/utility/PageUtils.java" />
              <option name="updatedContent" value="package com.storemanagement.utility;&#10;&#10;import com.storemanagement.dto.PageResponse;&#10;import org.springframework.data.domain.Page;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Utility class để chuyển đổi Spring Data Page sang PageResponse DTO&#10; */&#10;public class PageUtils {&#10;    &#10;    /**&#10;     * Chuyển đổi Spring Data Page sang PageResponse&#10;     * &#10;     * @param page Spring Data Page object&#10;     * @param &lt;T&gt; Kiểu dữ liệu của items&#10;     * @return PageResponse chứa dữ liệu phân trang&#10;     */&#10;    public static &lt;T&gt; PageResponse&lt;T&gt; toPageResponse(Page&lt;T&gt; page) {&#10;        return PageResponse.&lt;T&gt;builder()&#10;                .content(page.getContent())&#10;                .pageNumber(page.getNumber())&#10;                .pageSize(page.getSize())&#10;                .totalElements(page.getTotalElements())&#10;                .totalPages(page.getTotalPages())&#10;                .isFirst(page.isFirst())&#10;                .isLast(page.isLast())&#10;                .hasNext(page.hasNext())&#10;                .hasPrevious(page.hasPrevious())&#10;                .isEmpty(page.isEmpty())&#10;                .build();&#10;    }&#10;    &#10;    /**&#10;     * Chuyển đổi Spring Data Page với mapping content sang kiểu khác&#10;     * &#10;     * @param page Spring Data Page object&#10;     * @param mappedContent Danh sách đã được map sang kiểu mới&#10;     * @param &lt;T&gt; Kiểu dữ liệu của items trong response&#10;     * @return PageResponse chứa dữ liệu phân trang&#10;     */&#10;    public static &lt;T&gt; PageResponse&lt;T&gt; toPageResponse(Page&lt;?&gt; page, List&lt;T&gt; mappedContent) {&#10;        return PageResponse.&lt;T&gt;builder()&#10;                .content(mappedContent)&#10;                .pageNumber(page.getNumber())&#10;                .pageSize(page.getSize())&#10;                .totalElements(page.getTotalElements())&#10;                .totalPages(page.getTotalPages())&#10;                .isFirst(page.isFirst())&#10;                .isLast(page.isLast())&#10;                .hasNext(page.hasNext())&#10;                .hasPrevious(page.hasPrevious())&#10;                .isEmpty(page.isEmpty())&#10;                .build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>